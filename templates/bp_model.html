{% extends "base.html" %}

{% block title %}BP 神经网络分析{% endblock %}

{% block content %}
<div class="card">
    <div class="tabs">
        <div class="tab active">模型简介</div>
        <div class="tab">失效数据</div>
        <div class="tab">预测分析</div>
    </div>
    
    <div class="tab-content">
         <div class="tab-content">
                <!-- 模型简介内容 -->
                <div id="model-intro-content" style="display: block;">
                    <div class="section">
                        <h3>BP神经网络模型简介</h3>
                        <p>BP（Back Propagation，反向传播）神经网络是一种典型的前馈神经网络，适用于非线性函数拟合与时间序列预测。</p>
                        
                        <h4>模型特点</h4>
                        <ul>
                            <li>能够拟合复杂的非线性关系</li>
                            <li>可通过调整网络结构和超参数提升预测精度</li>
                            <li>适用于软件失效时间序列等连续数据的趋势预测</li>
                        </ul>
                        
                        <h4>本系统中的应用</h4>
                        <ul>
                            <li>根据历史失效时间序列，预测未来若干次失效时间</li>
                            <li>评估模型在验证集上的 MAE/MSE/RMSE/R² 等指标</li>
                        </ul>
                    </div>
                </div>
        
        <div id="dataset-content" style="display: none;">
            <div class="dataset-section">    
                <h3>数据集选择</h3>
                <div class="form-group">
                    <label for="dataset-select">选择数据集:</label>
                    <select id="dataset-select" style="width:100%; height:38px; border:1px solid #d9d9d9; border-radius:4px; padding:6px 8px;">
                        <option value="default">默认数据集</option>
                        <option value="custom">自定义数据集</option>
                        <option value="dataset1">数据集1 (测试数据集)</option>
                        <option value="dataset2">数据集2 (项目数据集)</option>
                        <optgroup id="cloud-datasets-group" label="我的云端数据"></optgroup>
                    </select>
                    <small>选择不同的数据集进行模型训练和预测</small>
                </div>
                
                <div id="custom-dataset-group" style="display: none;">
                    <div class="form-group">
                        <label for="train-data-input">输入失效时间数据 (用逗号分隔):</label>
                        <textarea id="train-data-input" rows="5" placeholder="例如: 9,12,32,36..."></textarea>
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label" style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span>训练数据比例: <strong id="train-ratio-value" style="color: var(--primary-color);">70%</strong></span>
                        </div>
                        <input type="range" id="train-ratio-slider" min="10" max="90" value="70" style="width: 100%;">
                    </div>
                    
                    <div class="form-group">
                        <button id="load-dataset-btn">加载数据集</button>
                    </div>
                </div>
                
                <div id="dataset-preview" class="data-preview"></div>
            </div>
        </div>
        
        <div id="prediction-content" style="display: none;">
            <form id="prediction-form">
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;">
                    <div class="form-group">
                        <label for="prediction-step">预测步长:</label>
                        <input type="number" id="prediction-step" name="prediction-step" value="5" min="1" max="100">
                    </div>
                    <div class="form-group">
                        <label for="look-back">滑动窗口 (look_back):</label>
                        <input type="number" id="look-back" name="look-back" value="5" min="1" max="20">
                    </div>
                    <div class="form-group">
                        <label for="hidden-size">网络规模参数:</label>
                        <input type="number" id="hidden-size" name="hidden-size" value="10" min="1" max="50">
                        <small style="display: block; color: #666; margin-top: 4px;">
                            实际网络结构：第一层隐含层 = 参数×10，第二层隐含层 = 第一层×60%<br>
                            例如：参数=10 → 第一层100个神经元，第二层60个神经元
                        </small>
                    </div>
                    <div class="form-group">
                        <label for="lr">学习率 (lr):</label>
                        <input type="number" step="0.001" id="lr" name="lr" value="0.05" min="0.001" max="1">
                    </div>
                    <div class="form-group">
                        <label for="epochs">训练轮数 (epochs):</label>
                        <input type="number" id="epochs" name="epochs" value="500" min="10" max="10000">
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <button type="button" id="train-btn" style="background: #fff; color: var(--primary-color); border: 1px solid var(--primary-color); margin-right: 10px;">训练模型</button>
                    <button type="button" id="predict-btn" style="background: #52c41a;">训练并预测</button>
                </div>
            </form>

            <div class="result-section" style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
                <h3>预测结果</h3>
                
                <div id="message-area"></div>
                
                <div id="accuracy-metrics" class="accuracy-metrics" style="display: none;">
                    <div class="metric-card"><h4>MAE</h4><p id="mae-value">-</p></div>
                    <div class="metric-card"><h4>MSE</h4><p id="mse-value">-</p></div>
                    <div class="metric-card"><h4>RMSE</h4><p id="rmse-value">-</p></div>
                    <div class="metric-card"><h4>R²</h4><p id="r2-value">-</p></div>
                    <div class="metric-card"><h4>准确率</h4><p id="accuracy-value">-</p></div>
                </div>
                
                <div class="chart-container" style="height: 400px; margin-top: 25px;">
                    <canvas id="failure-chart"></canvas>
                </div>
                
                <div id="result-data" style="margin-top: 20px; padding: 15px; background: #f9f9f9; border-radius: 4px;"></div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- 以下代码完全保留自原版逻辑，不做任何修改 ---
    let failureChart;
    let currentDataset = [];
    let trainData = [];
    let testData = [];
    let modelTrained = false;
    
    const DATASETS = {
        'default': [9,21,32,36,43,45,50,58,63,70,71,77,78,87,91,92,95,103,109,110,111,144,151,242,244,245,332,379,391,400,535,793,809,844],
        'dataset1': [2, 4, 6, 8, 11, 14, 17, 21, 26, 32, 39, 47, 56, 66, 77, 89],
        'dataset2': [3, 5, 7, 9, 12, 15, 18, 22, 27, 33, 40, 48, 57, 67, 78]
    };
    
    function initCharts() {
        const failureCtx = document.getElementById('failure-chart').getContext('2d');
        failureChart = new Chart(failureCtx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Historical Failures',
                    data: [],
                    backgroundColor: 'rgba(75, 192, 192, 0.5)'
                }, {
                    label: 'Predicted Failures',
                    data: [],
                    backgroundColor: 'rgba(255, 99, 132, 0.5)'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false, // 适配新布局
                scales: {
                    x: { title: { display: true, text: 'Failure Sequence' } },
                    y: { title: { display: true, text: 'Failure Time' } }
                }
            }
        });
    }
    
    function updateCharts(historicalFailures, predictedFailures) {
        if (historicalFailures && historicalFailures.length > 0) {
            const historicalData = historicalFailures.map((time, index) => ({
                x: index + 1,
                y: time
            }));
            
            const predictedData = predictedFailures ? predictedFailures.map((time, index) => ({
                x: index + 1 + historicalFailures.length,
                y: time
            })) : [];
            
            failureChart.data.datasets[0].data = historicalData;
            failureChart.data.datasets[1].data = predictedData;
            failureChart.update();
        }
    }
    
    function showMessage(message, type = 'info') {
        const messageArea = document.getElementById('message-area');
        messageArea.innerHTML = '';
        const messageDiv = document.createElement('div');
        messageDiv.className = type === 'error' ? 'error' : type === 'warning' ? 'warning' : type === 'success' ? 'success' : 'info';
        const messageType = type === 'error' ? '错误' : type === 'warning' ? '警告' : type === 'success' ? '成功' : '信息';
        messageDiv.innerHTML = `<strong>${messageType}:</strong> ${message}`;
        messageArea.appendChild(messageDiv);
        if (type !== 'error') { setTimeout(() => { messageDiv.remove(); }, 3000); }
    }

    // 数字格式化，控制显示位数
    function formatNum(value, digits = 6) {
        const n = Number(value);
        if (!Number.isFinite(n)) return 'N/A';
        return Number(n.toFixed(digits)).toString();
    }

    function formatPct(value, digits = 3) {
        const n = Number(value);
        if (!Number.isFinite(n)) return 'N/A';
        return `${formatNum(n, digits)}%`;
    }

    // 拉取云端数据列表，填充下拉框
    function fetchDatasetList() {
        fetch('/api/data/list')
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                const select = document.getElementById('dataset-select');
                let group = document.getElementById('cloud-datasets-group');
                if (!group) {
                    group = document.createElement('optgroup');
                    group.id = 'cloud-datasets-group';
                    group.label = '我的云端数据';
                    select.appendChild(group);
                }
                group.innerHTML = '';
                data.data.forEach(item => {
                    const opt = document.createElement('option');
                    opt.value = `db:${item.id}`;
                    opt.textContent = `[云端] ${item.name} (${item.count}点)`;
                    group.appendChild(opt);
                });
            }
        })
        .catch(() => {});
    }

    // 数字格式化，控制显示位数
    function formatNum(value, digits = 6) {
        const n = Number(value);
        if (!Number.isFinite(n)) return 'N/A';
        return Number(n.toFixed(digits)).toString();
    }

    function formatPct(value, digits = 3) {
        const n = Number(value);
        if (!Number.isFinite(n)) return 'N/A';
        return `${formatNum(n, digits)}%`;
    }
    
    function parseCustomDataset() {
        const input = document.getElementById('train-data-input').value.trim();
        if (!input) { showMessage("请输入失效时间数据", 'error'); return null; }
        try {
            const numbers = input.split(',').map(item => item.trim()).filter(item => item.length > 0).map(item => {
                const num = parseFloat(item);
                if (isNaN(num) || num <= 0) { throw new Error(`无效的数值: ${item}`); }
                return num;
            });
            if (numbers.length < 6) { throw new Error("BP 模型建议至少提供 6 个以上失效时间点"); }
            return numbers;
        } catch (error) { showMessage(error.message, 'error'); return null; }
    }
    
    function splitTrainTestData(dataset, ratio) {
        const splitIndex = Math.floor(dataset.length * ratio / 100);
        return { train: dataset.slice(0, splitIndex), test: dataset.slice(splitIndex) };
    }
    
    function updateDatasetPreview(dataset) {
        const preview = document.getElementById('dataset-preview');
        if (dataset.length > 0) {
            preview.innerHTML = `<strong>数据集预览:</strong> [${dataset.slice(0, 10).join(', ')}${dataset.length > 10 ? ', ...' : ''}] (共 ${dataset.length} 个数据点)`;
        } else { preview.innerHTML = ''; }
    }
    
    function loadDataset(datasetName) {
        try {
            let dataset;
            // 处理云端数据
            if (datasetName && datasetName.startsWith('db:')) {
                const id = datasetName.split(':')[1];
                fetch(`/api/data/get/${id}`)
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        currentDataset = data.data || [];
                        const ratio = parseInt(document.getElementById('train-ratio-slider').value);
                        const splitResult = splitTrainTestData(currentDataset, ratio);
                        trainData = splitResult.train;
                        testData = splitResult.test;
                        showMessage(`云端数据加载成功 (训练: ${trainData.length}, 测试: ${testData.length})`, 'success');
                        updateDatasetPreview(currentDataset);
                        modelTrained = false;
                        updateCharts(trainData, []);
                    } else {
                        showMessage('加载失败: ' + data.error, 'error');
                    }
                })
                .catch(() => showMessage('网络错误', 'error'));
                return true;
            }

            if (datasetName === 'custom') {
                dataset = parseCustomDataset();
                if (!dataset) return false;
            } else if (datasetName in DATASETS) {
                dataset = DATASETS[datasetName];
            } else {
                showMessage(`未知的数据集: ${datasetName}`, 'error');
                return false;
            }
            
            currentDataset = dataset;
            
            if (datasetName === 'custom') {
                const ratio = parseInt(document.getElementById('train-ratio-slider').value);
                const splitResult = splitTrainTestData(dataset, ratio);
                trainData = splitResult.train;
                testData = splitResult.test;
                showMessage(`自定义数据集加载成功，训练数据: ${trainData.length} 个, 测试数据: ${testData.length} 个`, 'success');
            } else {
                trainData = dataset;
                testData = [];
                showMessage(`${datasetName === 'default' ? '默认数据集' : datasetName}加载成功，共 ${dataset.length} 个数据点`, 'success');
            }
            
            updateDatasetPreview(dataset);
            modelTrained = false;
            updateCharts(trainData, []);
            return true;
        } catch (error) { showMessage(`加载数据集失败: ${error.message}`, 'error'); return false; }
    }
    
    function trainModelOnly() {
        if (trainData.length === 0) { showMessage("请先加载数据集", 'error'); return; }
        const loadingSpinner = document.getElementById('loading-spinner');
        loadingSpinner.style.display = 'block'; // 注意：原版逻辑是 block
        
        try {
            const lookBack = parseInt(document.getElementById('look-back').value);
            const hiddenSize = parseInt(document.getElementById('hidden-size').value);
            const lr = parseFloat(document.getElementById('lr').value);
            const epochs = parseInt(document.getElementById('epochs').value);
            
            fetch('/api/bp/train', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', },
                body: JSON.stringify({
                    train_data: trainData,
                    look_back: lookBack,
                    hidden_size: hiddenSize,
                    lr: lr,
                    epochs: epochs
                }),
            })
            .then(response => {
                loadingSpinner.style.display = 'none';
                if (!response.ok) { return response.text().then(text => { throw new Error(`HTTP错误: ${response.status} - ${text}`); }); }
                return response.json();
            })
            .then(responseData => {
                if (!responseData) { throw new Error("服务器返回空响应"); }
                if (responseData.success) {
                    modelTrained = true;
                    showMessage(`模型训练成功，最终损失: ${responseData.final_loss.toFixed(6)}`, 'success');
                    const resultDiv = document.getElementById('result-data');
                    resultDiv.innerHTML = `<h4>模型训练结果</h4><p><strong>训练数据点数:</strong> ${responseData.used_train_count || trainData.length}</p><p><strong>损失函数最终值:</strong> ${responseData.final_loss.toFixed(6)}</p>`;
                } else { throw new Error(responseData.error || "模型训练失败"); }
            })
            .catch(error => { loadingSpinner.style.display = 'none'; showMessage(`训练模型失败: ${error.message}`, 'error'); });
            
        } catch (error) { loadingSpinner.style.display = 'none'; showMessage(`训练模型失败: ${error.message}`, 'error'); }
    }
    
    function trainAndPredict() {
        if (trainData.length === 0) { showMessage("请先加载数据集", 'error'); return; }
        const loadingSpinner = document.getElementById('loading-spinner');
        loadingSpinner.style.display = 'block'; // 原版逻辑
        
        try {
            const predictionStep = parseInt(document.getElementById('prediction-step').value);
            const lookBack = parseInt(document.getElementById('look-back').value);
            const hiddenSize = parseInt(document.getElementById('hidden-size').value);
            const lr = parseFloat(document.getElementById('lr').value);
            const epochs = parseInt(document.getElementById('epochs').value);
            
            if (isNaN(predictionStep) || predictionStep < 1 || predictionStep > 100) { throw new Error("预测步长必须是1-100之间的整数"); }
            
            const formData = {
                data_type: document.getElementById('dataset-select').value,
                prediction_step: predictionStep,
                look_back: lookBack,
                hidden_size: hiddenSize,
                lr: lr,
                epochs: epochs,
                train_data: trainData,
                test_data: testData
            };
            
            fetch('/api/bp/predict', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', },
                body: JSON.stringify(formData),
            })
            .then(response => {
                loadingSpinner.style.display = 'none';
                if (!response.ok) { return response.text().then(text => { throw new Error(`HTTP错误: ${response.status} - ${text}`); }); }
                return response.json();
            })
            .then(responseData => {
                if (!responseData) { throw new Error("服务器返回空响应"); }
                if (responseData.success) {
                    modelTrained = true;
                    showMessage("预测成功完成", 'success');
                    updatePredictionResults(responseData);
                } else { throw new Error(responseData.error || "预测失败"); }
            })
            .catch(error => { loadingSpinner.style.display = 'none'; showMessage(`预测失败: ${error.message}`, 'error'); });
            
        } catch (error) { loadingSpinner.style.display = 'none'; showMessage(error.message, 'error'); }
    }
    
    function updatePredictionResults(data) {
        const accuracyMetrics = document.getElementById('accuracy-metrics');
        accuracyMetrics.style.display = 'grid'; // 适配 CSS Grid
        
        document.getElementById('mae-value').textContent = formatNum(data.mae, 6);
        document.getElementById('mse-value').textContent = formatNum(data.mse, 6);
        document.getElementById('rmse-value').textContent = formatNum(data.rmse, 6);
        document.getElementById('r2-value').textContent = formatNum(data.r2_score, 6);
        document.getElementById('accuracy-value').textContent = formatPct(data.accuracy, 3);
        
        const resultDiv = document.getElementById('result-data');
        resultDiv.innerHTML = `
            <h4>预测结果</h4>
            <p><strong>下一次失效预测时间:</strong> ${data.next_failure_time !== undefined ? data.next_failure_time : 'N/A'}</p>
            <h5>未来失效时间预测点:</h5>
            <ul>
                ${data.predicted_times && data.predicted_times.length > 0 ? 
                    data.predicted_times.map((t, i) => `<li>第${i+1}次: ${t}</li>`).join('') : 
                    '<li>无预测数据</li>'}
            </ul>
        `;
        
        updateCharts(
            currentDataset.length > 0 ? currentDataset : trainData,
            data.predicted_times || []
        );
    }
    
    // 初始化页面
    document.addEventListener('DOMContentLoaded', function() {
        initCharts();
        
        document.getElementById('dataset-select').addEventListener('change', function() {
            const customGroup = document.getElementById('custom-dataset-group');
            if (this.value === 'custom') {
                customGroup.style.display = 'block';
            } else {
                customGroup.style.display = 'none';
                loadDataset(this.value);
            }
        });
        
        document.getElementById('train-ratio-slider').addEventListener('input', function() {
            document.getElementById('train-ratio-value').textContent = `${this.value}%`;
        });
        
        document.getElementById('load-dataset-btn').addEventListener('click', function() {
            loadDataset('custom');
        });
        
        document.getElementById('train-btn').addEventListener('click', function() {
            trainModelOnly();
        });
        
        document.getElementById('predict-btn').addEventListener('click', function() {
            trainAndPredict();
        });
        
        // Tab 切换逻辑
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                const tabContents = {
                    '模型简介': document.getElementById('model-intro-content'),
                    '失效数据': document.getElementById('dataset-content'),
                    '预测分析': document.getElementById('prediction-content')
                };
                
                Object.values(tabContents).forEach(content => {
                    if (content) content.style.display = 'none';
                });
                
                const tabName = this.textContent.trim();
                if (tabContents[tabName]) {
                    tabContents[tabName].style.display = 'block';
                }
            });
        });
        
        document.querySelectorAll('.tab')[0].click();
        loadDataset('default');
        fetchDatasetList();
    });
</script>
{% endblock %}