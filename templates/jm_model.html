{% extends "base.html" %}

{% block title %}JM 模型分析{% endblock %}

{% block content %}
<div class="card">
    <div class="tabs">
        <div class="tab active">模型简介</div>
        <div class="tab">失效数据</div>
        <div class="tab">预测分析</div>
    </div>
    
    <div class="tab-content">
        <div id="model-intro-content" style="display: block;">
<div class="section">
                        <h3>JM模型简介</h3>
                        <p>JM模型（Jelinski-Moranda模型）是软件可靠性分析中经典的NHPP（非齐次泊松过程）模型之一，用于评估和预测软件系统的可靠性。</p>
                        
                        <h4>模型基本概念</h4>
                        <ul>
                            <li>假设软件中初始存在N₀个故障</li>
                            <li>每次故障修复后软件可靠性提高</li>
                            <li>故障检测率与当前剩余故障数成正比</li>
                            <li>模型参数包括初始故障数N₀和故障检测率φ</li>
                        </ul>
                        
                        <h4>模型应用场景</h4>
                        <ul>
                            <li>软件测试过程中的可靠性评估</li>
                            <li>剩余故障数预测</li>
                            <li>未来失效时间预测</li>
                            <li>软件发布决策支持</li>
                        </ul>
                        
                        <h4>模型数学表达式</h4>
                        <p>JM模型的核心数学表达式为：</p>
                        <ul>
                            <li>故障检测率：φ(t) = φ × (N₀ - m(t))</li>
                            <li>累计失效函数：m(t) = N₀ × (1 - e^(-φ×t))</li>
                            <li>可靠度函数：R(t) = e^(-φ×N₀×t)</li>
                            <li>失效强度函数：λ(t) = φ × N₀ × e^(-φ×N₀×t)</li>
                        </ul>
                        
                        <h4>模型优势</h4>
                        <ul>
                            <li>模型结构简单，易于理解和应用</li>
                            <li>参数估计相对稳定</li>
                            <li>适用于大多数软件开发场景</li>
                        </ul>
                        
                        <h4>模型局限性</h4>
                        <ul>
                            <li>假设故障检测率与剩余故障数线性相关</li>
                            <li>忽略故障之间的相互影响</li>
                            <li>假设故障修复完全且不引入新故障</li>
                        </ul>
                    </div>
            </div>
        </div>
        
        <div id="dataset-content" style="display: none;">
            <div class="dataset-section">    
                <h3>数据集配置</h3>
                <div class="form-group">
                    <label for="dataset-select">选择数据集:</label>
                    <select id="dataset-select">
                        <option value="default">默认数据集</option>
                        <option value="custom">自定义数据集</option>
                        <option value="dataset1">数据集1 (测试数据集)</option>
                        <option value="dataset2">数据集2 (项目数据集)</option>
                    </select>
                </div>
                
                <div id="custom-dataset-group" style="display: none;">
                    <div class="form-group">
                        <label for="train-data-input">输入失效时间数据 (用逗号分隔):</label>
                        <textarea id="train-data-input" rows="5" placeholder="例如: 9,12,11..."></textarea>
                    </div>
                    <div class="form-group">
                        <button id="load-dataset-btn">加载自定义数据</button>
                    </div>
                </div>

                <div class="slider-container" style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px;">
                    <div class="slider-label" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span>训练数据比例: <strong id="train-ratio-value" style="color: var(--primary-color);">77%</strong></span>
                    </div>
                    <input type="range" id="train-ratio-slider" min="10" max="90" value="77" style="width: 100%;" onchange="reloadCurrentDatasetSplit()">
                </div>
                
                <div id="dataset-preview" class="data-preview" style="margin-top: 20px; padding: 15px; background: #fafafa; border: 1px dashed #d9d9d9; border-radius: 4px; color: #666;">
                    </div>
            </div>
        </div>
        
        <div id="prediction-content" style="display: none;">
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;">
                <div class="form-group">
                    <label for="prediction-step">预测步长:</label>
                    <input type="number" id="prediction-step" name="prediction-step" value="5" min="1" max="100">
                </div>
                
                <div class="form-group">
                    <label for="ex">预测精度 ex:</label>
                    <input type="number" step="0.001" id="ex" name="ex" value="0.001" min="0" max="1">
                </div>
                
                <div class="form-group">
                    <label for="ey">预测精度 ey:</label>
                    <input type="number" step="0.001" id="ey" name="ey" value="0.001" min="0" max="1">
                </div>
            </div>

            <div class="form-group" style="margin-top: 20px;">
                <button type="button" id="train-btn" style="margin-right: 15px;">仅训练模型</button>
                <button type="button" id="predict-btn" style="background-color: #52c41a;">训练并预测</button>
            </div>

            <div class="result-section" style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
                <h3>分析结果</h3>
                
                <div id="message-area"></div>
                
                <div id="accuracy-metrics" class="accuracy-metrics" style="display: none;">
                    <div class="metric-card"><h4>平均绝对误差 (MAE)</h4><p id="mae-value">-</p></div>
                    <div class="metric-card"><h4>均方误差 (MSE)</h4><p id="mse-value">-</p></div>
                    <div class="metric-card"><h4>均方根误差 (RMSE)</h4><p id="rmse-value">-</p></div>
                    <div class="metric-card"><h4>决定系数 (R²)</h4><p id="r2-value">-</p></div>
                    <div class="metric-card"><h4>模型准确率</h4><p id="accuracy-value">-</p></div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 30px;">
                    <div style="height: 400px;"><canvas id="reliability-chart"></canvas></div>
                    <div style="height: 400px;"><canvas id="failure-chart"></canvas></div>
                </div>
                
                <div id="result-data" style="margin-top: 20px; background: #f9f9f9; padding: 20px; border-radius: 4px;"></div>
            </div>
        </div>
    </div>
</div>

<script>
    // 原始 JavaScript 代码保持完全不变
    // 全局变量
    let reliabilityChart;
    let failureChart;
    let currentDataset = [];
    let trainData = [];
    let testData = [];
    let modelTrained = false;
    
    // 数据集示例
    const DATASETS = {
        'default': [9,12,11,4,7,2,5,8,5,7,1,6,1,9,4,1,3,8,6,1,1,33,7,91,2,1,87,47,12,9,135,258,16,35],
        'dataset1':[5, 1, 4, 5, 3, 1, 1, 6, 1, 1, 6, 16, 1, 4, 10, 6, 8, 2, 18, 10, 7, 1, 4, 12, 7, 7, 13, 11, 19, 19, 41, 23, 100],
        'dataset2': [1, 30, 6, 2, 7, 3, 18, 1, 1, 14, 1, 14, 1, 10, 17, 23, 44, 7, 5, 22, 6, 12, 1, 19, 7, 10, 19, 6, 31, 14, 17, 21, 6, 1, 6, 5, 38, 5, 4, 39, 25, 10, 45, 22, 1, 7, 37, 20, 20, 36, 22, 7, 12, 10, 6, 8, 31, 55, 7, 47, 59, 27, 17, 9, 9, 17, 4, 11, 139, 58, 3, 24, 107, 259, 56, 168]
    }; 

    function initCharts() {
        const reliabilityCtx = document.getElementById('reliability-chart').getContext('2d');
        reliabilityChart = new Chart(reliabilityCtx, {
            type: 'line',
            data: { labels: [], datasets: [{ label: 'Reliability', data: [], borderColor: 'rgb(75, 192, 192)', tension: 0.1 }] },
            options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: false, min: 0, max: 1 }, x: { title: { display: true, text: 'Time' } } } }
        });
        
        const failureCtx = document.getElementById('failure-chart').getContext('2d');
        failureChart = new Chart(failureCtx, {
            type: 'scatter',
            data: { datasets: [{ label: 'Historical Failures', data: [], backgroundColor: 'rgba(75, 192, 192, 0.5)' }, { label: 'Predicted Failures', data: [], backgroundColor: 'rgba(255, 99, 132, 0.5)' }] },
            options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'Failure Sequence' } }, y: { title: { display: true, text: 'Time' } } } }
        });
    }
    
    function updateCharts(reliabilityData, historicalFailures, predictedFailures) {
        if (reliabilityData && reliabilityData.length > 0) {
            reliabilityChart.data.labels = reliabilityData.map(point => point.time);
            reliabilityChart.data.datasets[0].data = reliabilityData.map(point => point.reliability);
            reliabilityChart.update();
        }
        if (historicalFailures && historicalFailures.length > 0) {
            const historicalData = historicalFailures.map((time, index) => ({ x: index + 1, y: time }));
            let currentCumulativeTime = historicalFailures[historicalFailures.length - 1] || 0;
            const predictedData = predictedFailures ? predictedFailures.map((interval, index) => {
                currentCumulativeTime += interval; 
                return { x: index + 1 + historicalFailures.length, y: currentCumulativeTime };
            }) : [];
            failureChart.data.datasets[0].data = historicalData;
            failureChart.data.datasets[1].data = predictedData;
            failureChart.update();
        }
    }
    
    function showMessage(message, type = 'info') {
        const messageArea = document.getElementById('message-area');
        messageArea.innerHTML = '';
        const messageDiv = document.createElement('div');
        messageDiv.className = type;
        messageDiv.innerHTML = `<strong>${type === 'error' ? '错误' : type === 'warning' ? '警告' : type === 'success' ? '成功' : '信息'}:</strong> ${message}`;
        messageArea.appendChild(messageDiv);
        if (type !== 'error') setTimeout(() => { messageDiv.remove(); }, 3000);
    }

    // 数字格式化，控制显示位数
    function formatNum(value, digits = 6) {
        const n = Number(value);
        if (!Number.isFinite(n)) return 'N/A';
        return Number(n.toFixed(digits)).toString();
    }

    function formatPct(value, digits = 3) {
        const n = Number(value);
        if (!Number.isFinite(n)) return 'N/A';
        return `${formatNum(n, digits)}%`;
    }
    
    function parseCustomDataset() {
        const input = document.getElementById('train-data-input').value.trim();
        if (!input) { showMessage("请输入失效时间数据", 'error'); return null; }
        try {
            const numbers = input.split(',').map(item => item.trim()).filter(item => item.length > 0).map(item => {
                const num = parseFloat(item);
                if (isNaN(num) || num <= 0) throw new Error(`无效的数值: ${item}`);
                return num;
            });
            if (numbers.length < 2) throw new Error("数据集至少需要包含2个数据点");
            return numbers;
        } catch (error) { showMessage(error.message, 'error'); return null; }
    }
    
    function splitTrainTestData(dataset, ratio) {
        const splitIndex = Math.floor(dataset.length * ratio / 100);
        return { train: dataset.slice(0, splitIndex), test: dataset.slice(splitIndex) };
    }
    
    function updateDatasetPreview(dataset) {
        const preview = document.getElementById('dataset-preview');
        if (dataset.length > 0) {
            preview.innerHTML = `<strong>数据集预览:</strong> [${dataset.slice(0, 10).join(', ')}${dataset.length > 10 ? ', ...' : ''}] (共 ${dataset.length} 个数据点)`;
        } else { preview.innerHTML = ''; }
    }
    
// 新增一个辅助函数，用于滑块拖动时重新划分
    function reloadCurrentDatasetSplit() {
        const select = document.getElementById('dataset-select');
        if (select.value !== 'custom') {
            loadDataset(select.value);
        } else {
            // 如果是自定义模式，且文本框里有内容，也重新加载
            loadDataset('custom');
        }
    }

    // 修改 loadDataset 函数
    function loadDataset(datasetName) {

        // 1. 处理数据库数据 (新增逻辑)
        if (datasetName.startsWith('db:')) {
            const id = datasetName.split(':')[1];
            fetch(`/api/data/get/${id}`)
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    currentDataset = data.data; // 获取到的数组
                    // 应用滑块比例
                    const ratio = parseInt(document.getElementById('train-ratio-slider').value);
                    const splitResult = splitTrainTestData(currentDataset, ratio);
                    trainData = splitResult.train;
                    testData = splitResult.test;
                    
                    showMessage(`数据库文件数据加载成功 (共${currentDataset.length}条)`, 'success');
                    updateDatasetPreview(currentDataset);
                    modelTrained = false;
                } else {
                    showMessage('加载失败: ' + data.error, 'error');
                }
            })
            .catch(err => showMessage('网络错误', 'error'));
            return true;
        }

        try {
            let dataset;
            
            // 1. 获取原始数据
            if (datasetName === 'custom') {
                dataset = parseCustomDataset();
                if (!dataset) return false;
            } else if (datasetName in DATASETS) {
                dataset = DATASETS[datasetName];
            } else {
                showMessage(`未知的数据集: ${datasetName}`, 'error');
                return false;
            }
            
            currentDataset = dataset;
            
            // 2. 【核心修改】无论是什么数据集，都读取滑块比例进行划分
            // 获取滑块当前的值 (例如 77)
            const ratio = parseInt(document.getElementById('train-ratio-slider').value);
            
            // 调用划分函数
            const splitResult = splitTrainTestData(dataset, ratio);
            
            trainData = splitResult.train;
            testData = splitResult.test;
            
            // 3. 更新提示信息
            let typeName = datasetName === 'default' ? '默认数据集' : (datasetName === 'custom' ? '自定义数据集' : datasetName);
            
            showMessage(`${typeName}加载成功 (训练比 ${ratio}%)：训练集 ${trainData.length} 个，测试集 ${testData.length} 个`, 'success');
            
            updateDatasetPreview(dataset); // 这里展示全部数据
            
            // 可选：在预览里显示具体的划分情况
            const preview = document.getElementById('dataset-preview');
            preview.innerHTML += `<br><span style="color:green; font-size:0.9em;">(前 ${trainData.length} 个用于训练，后 ${testData.length} 个用于验证)</span>`;

            modelTrained = false;
            return true;
        } catch (error) { 
            showMessage(`加载数据集失败: ${error.message}`, 'error'); 
            return false; 
        }
    }
    function trainModel() {
        if (trainData.length === 0) { showMessage("请先加载数据集", 'error'); return; }
        if (window.GlobalLoading) { GlobalLoading.showDelayed(); }
        try {
            fetch('/api/jm/train', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', },
                body: JSON.stringify({ train_data: trainData, ex: parseFloat(document.getElementById('ex').value), ey: parseFloat(document.getElementById('ey').value) }),
            })
            .then(response => {
                if (window.GlobalLoading) { GlobalLoading.hide(); }
                if (!response.ok) return response.text().then(text => { throw new Error(`HTTP错误: ${response.status} - ${text}`); });
                return response.json();
            })
            .then(responseData => {
                if (!responseData) throw new Error("服务器返回空响应");
                if (responseData.success) {
                    modelTrained = true;
                    showMessage("模型训练成功", 'success');
                    if (responseData.N0 && responseData.phi) {
                        document.getElementById('result-data').innerHTML = `<h4>模型训练结果</h4><p><strong>模型参数:</strong> N0 = ${responseData.N0}, φ = ${responseData.phi}</p><p><strong>训练数据点数:</strong> ${trainData.length}</p><p><strong>训练时间:</strong> ${new Date().toLocaleString()}</p>`;
                    }
                } else { throw new Error(responseData.error || "模型训练失败"); }
            })
            .catch(error => { if (window.GlobalLoading) { GlobalLoading.hide(); } showMessage(`训练模型失败: ${error.message}`, 'error'); });
        } catch (error) { if (window.GlobalLoading) { GlobalLoading.hide(); } showMessage(`训练模型失败: ${error.message}`, 'error'); }
    }
    
    function performPrediction() {
        if (trainData.length === 0) { showMessage("请先加载数据集", 'error'); return; }
        if (window.GlobalLoading) { GlobalLoading.showDelayed(); }
        try {
            const predictionStep = parseInt(document.getElementById('prediction-step').value);
            const ex = parseFloat(document.getElementById('ex').value);
            const ey = parseFloat(document.getElementById('ey').value);
            if (isNaN(predictionStep) || predictionStep < 1 || predictionStep > 100) throw new Error("预测步长必须是1-100之间的整数");
            const formData = { data_type: document.getElementById('dataset-select').value, prediction_step: predictionStep, ex: ex, ey: ey, train_data: trainData, test_data: testData };
            fetch('/api/jm/predict', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', },
                body: JSON.stringify(formData),
            })
            .then(response => {
                if (window.GlobalLoading) { GlobalLoading.hide(); }
                if (!response.ok) return response.text().then(text => { throw new Error(`HTTP错误: ${response.status} - ${text}`); });
                return response.json();
            })
            .then(responseData => {
                if (!responseData) throw new Error("服务器返回空响应");
                if (responseData.success) {
                    showMessage("预测成功完成", 'success');
                    updatePredictionResults(responseData);
                } else { throw new Error(responseData.error || "预测失败"); }
            })
            .catch(error => { if (window.GlobalLoading) { GlobalLoading.hide(); } showMessage(`预测失败: ${error.message}`, 'error'); });
        } catch (error) { if (window.GlobalLoading) { GlobalLoading.hide(); } showMessage(error.message, 'error'); }
    }
    
    function updatePredictionResults(data) {
        const accuracyMetrics = document.getElementById('accuracy-metrics');
        accuracyMetrics.style.display = 'grid';
        document.getElementById('mae-value').textContent = formatNum(data.mae, 6);
        document.getElementById('mse-value').textContent = formatNum(data.mse, 6);
        document.getElementById('rmse-value').textContent = formatNum(data.rmse, 6);
        document.getElementById('r2-value').textContent = formatNum(data.r2_score, 6);
        document.getElementById('accuracy-value').textContent = formatPct(data.accuracy, 3);
        const resultDiv = document.getElementById('result-data');
        resultDiv.innerHTML = `<h4>预测结果</h4><p><strong>模型参数:</strong> N0 = ${data.N0}, φ = ${data.phi}</p><p><strong>剩余故障数:</strong> ${data.remaining_faults}</p><p><strong>下一次失效预测时间:</strong> ${data.next_failure_time !== undefined ? data.next_failure_time : 'N/A'}</p><h5>未来失效时间间隔预测:</h5><ul>${data.predicted_intervals && data.predicted_intervals.length > 0 ? data.predicted_intervals.map((interval, i) => `<li>第${i+1}次: ${interval}</li>`).join('') : '<li>无预测数据</li>'}</ul>`;
        updateCharts(data.reliability_curve || [], data.historical_failures || trainData, data.predicted_intervals || []);
    }

    // 【新增】获取列表并填充下拉框
    function fetchDatasetList() {
        fetch('/api/data/list')
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                const select = document.getElementById('dataset-select');
                // 创建分组
                const group = document.createElement('optgroup');
                group.label = "我的云端数据";
                
                data.data.forEach(item => {
                    const opt = document.createElement('option');
                    opt.value = `db:${item.id}`; // 使用特殊前缀 db:
                    opt.textContent = `[云端] ${item.name} (${item.count}点)`;
                    group.appendChild(opt);
                });
                select.appendChild(group);
            }
        });
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        initCharts();
        document.getElementById('dataset-select').addEventListener('change', function() {
            const customGroup = document.getElementById('custom-dataset-group');
            if (this.value === 'custom') { customGroup.style.display = 'block'; } 
            else { customGroup.style.display = 'none'; loadDataset(this.value); }
        });
        document.getElementById('train-ratio-slider').addEventListener('input', function() { document.getElementById('train-ratio-value').textContent = `${this.value}%`; });
        document.getElementById('load-dataset-btn').addEventListener('click', function() { loadDataset('custom'); });
        document.getElementById('train-btn').addEventListener('click', function() { trainModel(); });
        document.getElementById('predict-btn').addEventListener('click', function() { performPrediction(); });
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                const tabContents = { '模型简介': document.getElementById('model-intro-content'), '失效数据': document.getElementById('dataset-content'), '预测分析': document.getElementById('prediction-content') };
                Object.values(tabContents).forEach(content => { if (content) content.style.display = 'none'; });
                const tabName = this.textContent.trim();
                if (tabContents[tabName]) { tabContents[tabName].style.display = 'block'; }
            });
        });
        document.querySelectorAll('.tab')[0].click();
        loadDataset('default');

        fetchDatasetList();
    });
</script>
{% endblock %}