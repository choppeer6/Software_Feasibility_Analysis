{% extends "base.html" %}

{% block title %}GM11 模型分析{% endblock %}

{% block content %}
<div class="card">
    <div class="tabs">
        <div class="tab active">模型简介</div>
        <div class="tab">失效数据</div>
        <div class="tab">预测分析</div>
    </div>

    <div class="tab-content">
        <div id="model-intro-content" style="display: block;">
            <div class="section">
                <h3>GM11模型简介</h3>
                <p>GM(1,1)模型（一阶灰色预测模型）是灰色系统理论中的经典预测模型，适用于小样本、信息不完全的时间序列预测。</p>

                <h4>模型基本概念</h4>
                <ul>
                    <li>通过累加生成（1-AGO）将原始序列转化为单调递增序列</li>
                    <li>利用白化方程 dx/dt + ax = b 进行建模</li>
                    <li>通过最小二乘法估计参数 a 和 b</li>
                    <li>适用于数据量较少、规律性不明显的预测场景</li>
                </ul>

                <h4>模型应用场景</h4>
                <ul>
                    <li>小样本失效时间序列预测</li>
                    <li>信息不完全的可靠性分析</li>
                    <li>短期失效间隔预测</li>
                    <li>数据量有限时的趋势预测</li>
                </ul>

                <h4>模型优势</h4>
                <ul>
                    <li>对数据量要求低（至少4个数据点）</li>
                    <li>不需要大量历史数据</li>
                    <li>计算简单，易于实现</li>
                    <li>适用于不确定性较大的系统</li>
                </ul>

                <h4>模型局限性</h4>
                <ul>
                    <li>预测精度受数据质量影响较大</li>
                    <li>对长期预测的准确性有限</li>
                    <li>假设数据满足指数增长规律</li>
                    <li>对异常值较为敏感</li>
                </ul>
            </div>
        </div>

        <div id="dataset-content" style="display: none;">
            <div class="dataset-section">
                <h3>数据集配置</h3>
                <div class="form-group">
                    <label for="dataset-select">选择数据集:</label>
                    <select id="dataset-select">
                        <option value="default">默认数据集</option>
                        <option value="custom">自定义数据集</option>
                        <option value="dataset1">数据集1 (测试数据集)</option>
                        <option value="dataset2">数据集2 (项目数据集)</option>
                    </select>
                </div>

                <div id="custom-dataset-group" style="display: none;">
                    <div class="form-group">
                        <label for="train-data-input">输入失效时间间隔数据 (用逗号分隔):</label>
                        <textarea id="train-data-input" rows="5" placeholder="例如: 9,3,7,2,5..."></textarea>
                    </div>
                    <div class="form-group">
                        <button id="load-dataset-btn">加载自定义数据</button>
                    </div>
                </div>

                <div class="slider-container" style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px;">
                    <div class="slider-label" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span>训练数据比例: <strong id="train-ratio-value" style="color: var(--primary-color);">70%</strong></span>
                    </div>
                    <input type="range" id="train-ratio-slider" min="10" max="90" value="70" style="width: 100%;" onchange="reloadCurrentDatasetSplit()">
                </div>

                <div id="dataset-preview" class="data-preview" style="margin-top: 20px; padding: 15px; background: #fafafa; border: 1px dashed #d9d9d9; border-radius: 4px; color: #666;">
                </div>
            </div>
        </div>

        <div id="prediction-content" style="display: none;">
            <div class="form-group">
                <label for="prediction-step">预测步长:</label>
                <input type="number" id="prediction-step" name="prediction-step" value="5" min="1" max="100">
            </div>

            <div class="form-group" style="margin-top: 20px;">
                <button type="button" id="train-btn" style="margin-right: 15px;">仅训练模型</button>
                <button type="button" id="predict-btn" style="background-color: #52c41a;">训练并预测</button>
            </div>

            <!-- 加载动画 -->
            <div id="loading-spinner" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 9999;">
                <div style="border: 4px solid #f3f3f3; border-top: 4px solid var(--primary-color); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;"></div>
            </div>
            <style>
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
            </style>

            <div class="result-section" style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
                <h3>分析结果</h3>

                <div id="message-area"></div>

                <div id="accuracy-metrics" class="accuracy-metrics" style="display: none;">
                    <div class="metric-card"><h4>平均绝对误差 (MAE)</h4><p id="mae-value">-</p></div>
                    <div class="metric-card"><h4>均方误差 (MSE)</h4><p id="mse-value">-</p></div>
                    <div class="metric-card"><h4>均方根误差 (RMSE)</h4><p id="rmse-value">-</p></div>
                    <div class="metric-card"><h4>决定系数 (R²)</h4><p id="r2-value">-</p></div>
                    <div class="metric-card"><h4>模型准确率</h4><p id="accuracy-value">-</p></div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 30px;">
                    <div style="height: 400px;"><canvas id="failure-chart"></canvas></div>
                    <div style="height: 400px;"><canvas id="prediction-chart"></canvas></div>
                </div>

                <div id="result-data" style="margin-top: 20px; background: #f9f9f9; padding: 20px; border-radius: 4px;">
                    <h4>预测结果</h4>
<!--                    <p><strong>下一次失效预测时间:</strong> <span id="next-failure-time">N/A</span></p>-->

                    <h5>完整失效时间间隔序列:</h5>
                    <div style="max-height: 300px; overflow-y: auto; margin-bottom: 15px;">
                        <table class="data-table" style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr>
                                    <th style="border: 1px solid #ddd; padding: 8px;">序号</th>
                                    <th style="border: 1px solid #ddd; padding: 8px;">原始间隔</th>
                                    <th style="border: 1px solid #ddd; padding: 8px;">拟合间隔</th>
                                    <th style="border: 1px solid #ddd; padding: 8px;">残差</th>
                                    <th style="border: 1px solid #ddd; padding: 8px;">预测间隔</th>
                                </tr>
                            </thead>
                            <tbody id="interval-table-body">
                                <tr><td colspan="5" style="border: 1px solid #ddd; padding: 8px; text-align: center;">无数据</td></tr>
                            </tbody>
                        </table>
                    </div>
                    <br>
                    <h5>残差统计分析:</h5>
                    <div class="residual-stats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 15px;" id="residual-stats-container">
                        <div class="stat-card"><h6>残差均值</h6><p id="residual-mean">N/A</p></div>
                        <div class="stat-card"><h6>残差标准差</h6><p id="residual-std">N/A</p></div>
                        <div class="stat-card"><h6>最大残差</h6><p id="residual-max">N/A</p></div>
                        <div class="stat-card"><h6>最小残差</h6><p id="residual-min">N/A</p></div>
                        <div class="stat-card"><h6>残差范围</h6><p id="residual-range">N/A</p></div>
                    </div>

<!--                    <h5>未来失效时间预测点:</h5>-->
<!--                    <ul id="prediction-times-list">-->
<!--                        <li>无预测数据</li>-->
<!--                    </ul>-->
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let failureChart;
    let predictionChart;
    let currentDataset = [];
    let trainData = [];
    let testData = [];
    let modelTrained = false;

    const DATASETS = {
        'default': [9,12,11,4,7,2,5,8,5,7,1,6,1,9,4,1,3,8,6,1,1,33,7,91,2,1,87,47,12,9,135,258,16,35],
        'dataset1':[5, 1, 4, 5, 3, 1, 1, 6, 1, 1, 6, 16, 1, 4, 10, 6, 8, 2, 18, 10, 7, 1, 4, 12, 7, 7, 13, 11, 19, 19, 41, 23, 100],
        'dataset2': [1, 30, 6, 2, 7, 3, 18, 1, 1, 14, 1, 14, 1, 10, 17, 23, 44, 7, 5, 22, 6, 12, 1, 19, 7, 10, 19, 6, 31, 14, 17, 21, 6, 1, 6, 5, 38, 5, 4, 39, 25, 10, 45, 22, 1, 7, 37, 20, 20, 36, 22, 7, 12, 10, 6, 8, 31, 55, 7, 47, 59, 27, 17, 9, 9, 17, 4, 11, 139, 58, 3, 24, 107, 259, 56, 168]
    };

    function initCharts() {
        const failureCtx = document.getElementById('failure-chart').getContext('2d');
        failureChart = new Chart(failureCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: '累积失效时间',
                    data: [],
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                    tension: 0.1,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: '累积失效时间趋势'
                    }
                },
                scales: {
                    x: { title: { display: true, text: '失效序号' } },
                    y: { title: { display: true, text: '累积失效时间' } }
                }
            }
        });

        const predictionCtx = document.getElementById('prediction-chart').getContext('2d');
        predictionChart = new Chart(predictionCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '原始失效间隔',
                        data: [],
                        borderColor: 'rgb(54, 162, 235)',
                        backgroundColor: 'rgba(54, 162, 235, 0.1)',
                        tension: 0.1,
                        pointRadius: 3
                    },
                    {
                        label: '拟合失效间隔',
                        data: [],
                        borderColor: 'rgb(255, 159, 64)',
                        backgroundColor: 'rgba(255, 159, 64, 0.1)',
                        tension: 0.1,
                        borderDash: [5, 5],
                        pointRadius: 3
                    },
                    {
                        label: '预测失效间隔',
                        data: [],
                        borderColor: 'rgb(255, 99, 132)',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        tension: 0.1,
                        pointRadius: 4
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: '失效间隔时间序列分析'
                    }
                },
                scales: {
                    x: { title: { display: true, text: '序号' } },
                    y: { title: { display: true, text: '时间间隔' } }
                }
            }
        });
    }

    function updateCharts(historicalData, fullIntervals, predictedIntervals) {
        // 更新左侧累积失效时间图表
        if (historicalData && historicalData.length > 0) {
            const cumulativeTimes = [];
            let sum = 0;
            for (let i = 0; i < historicalData.length; i++) {
                sum += historicalData[i];
                cumulativeTimes.push(sum);
            }

            failureChart.data.labels = Array.from({length: historicalData.length}, (_, i) => i + 1);
            failureChart.data.datasets[0].data = cumulativeTimes;
            failureChart.update();
        }

        // 更新右侧失效间隔图表
        if (fullIntervals && fullIntervals.length > 0) {
            const nOriginal = historicalData.length;
            const labels = Array.from({length: fullIntervals.length}, (_, i) => i + 1);

            // 原始数据（仅前nOriginal个）
            const originalData = historicalData.slice();
            // 拟合数据（全部，但预测部分用null填充）
            const fittedData = fullIntervals.slice(0, nOriginal).concat(Array(fullIntervals.length - nOriginal).fill(null));
            // 预测数据（前nOriginal个用null填充，后面是预测值）
            const predictedData = Array(nOriginal).fill(null).concat(fullIntervals.slice(nOriginal));

            predictionChart.data.labels = labels;
            predictionChart.data.datasets[0].data = originalData;
            predictionChart.data.datasets[1].data = fittedData;
            predictionChart.data.datasets[2].data = predictedData;
            predictionChart.update();
        }
    }

    function showMessage(message, type = 'info') {
        const messageArea = document.getElementById('message-area');
        messageArea.innerHTML = '';
        const messageDiv = document.createElement('div');
        messageDiv.className = type;
        messageDiv.innerHTML = `<strong>${type === 'error' ? '错误' : type === 'warning' ? '警告' : type === 'success' ? '成功' : '信息'}:</strong> ${message}`;
        messageArea.appendChild(messageDiv);
        if (type !== 'error') setTimeout(() => { messageDiv.remove(); }, 3000);
    }

    // 数字格式化，控制显示位数
    function formatNum(value, digits = 6) {
        const n = Number(value);
        if (!Number.isFinite(n)) return 'N/A';
        return Number(n.toFixed(digits)).toString();
    }

    function formatPct(value, digits = 3) {
        const n = Number(value);
        if (!Number.isFinite(n)) return 'N/A';
        return `${formatNum(n, digits)}%`;
    }

    function parseCustomDataset() {
        const input = document.getElementById('train-data-input').value.trim();
        if (!input) { showMessage("请输入失效时间间隔数据", 'error'); return null; }
        try {
            const numbers = input.split(',').map(item => item.trim()).filter(item => item.length > 0).map(item => {
                const num = parseFloat(item);
                if (isNaN(num) || num < 0) throw new Error(`无效的数值: ${item}`);
                return num;
            });
            if (numbers.length < 4) throw new Error("GM11模型至少需要4个数据点");
            return numbers;
        } catch (error) { showMessage(error.message, 'error'); return null; }
    }

    function splitTrainTestData(dataset, ratio) {
        const splitIndex = Math.floor(dataset.length * ratio / 100);
        return { train: dataset.slice(0, splitIndex), test: dataset.slice(splitIndex) };
    }

    function updateDatasetPreview(dataset) {
        const preview = document.getElementById('dataset-preview');
        if (dataset.length > 0) {
            preview.innerHTML = `<strong>数据集预览:</strong> [${dataset.slice(0, 10).join(', ')}${dataset.length > 10 ? ', ...' : ''}] (共 ${dataset.length} 个数据点)`;
        } else { preview.innerHTML = ''; }
    }

    function reloadCurrentDatasetSplit() {
        const select = document.getElementById('dataset-select');
        if (select.value !== 'custom') {
            loadDataset(select.value);
        } else {
            loadDataset('custom');
        }
    }

    function loadDataset(datasetName) {
        if (datasetName.startsWith('db:')) {
            const id = datasetName.split(':')[1];
            fetch(`/api/data/get/${id}`)
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    currentDataset = data.data;
                    const ratio = parseInt(document.getElementById('train-ratio-slider').value);
                    const splitResult = splitTrainTestData(currentDataset, ratio);
                    trainData = splitResult.train;
                    testData = splitResult.test;
                    showMessage(`数据库文件数据加载成功 (共${currentDataset.length}条)`, 'success');
                    updateDatasetPreview(currentDataset);
                    modelTrained = false;
                } else {
                    showMessage('加载失败: ' + data.error, 'error');
                }
            })
            .catch(err => showMessage('网络错误', 'error'));
            return true;
        }

        try {
            let dataset;
            if (datasetName === 'custom') {
                dataset = parseCustomDataset();
                if (!dataset) return false;
            } else if (datasetName in DATASETS) {
                dataset = DATASETS[datasetName];
            } else {
                showMessage(`未知的数据集: ${datasetName}`, 'error');
                return false;
            }

            currentDataset = dataset;
            const ratio = parseInt(document.getElementById('train-ratio-slider').value);
            const splitResult = splitTrainTestData(dataset, ratio);
            trainData = splitResult.train;
            testData = splitResult.test;

            showMessage(`数据集加载成功 (训练比 ${ratio}%)：训练集 ${trainData.length} 个，测试集 ${testData.length} 个`, 'success');
            updateDatasetPreview(dataset);
            modelTrained = false;
            return true;
        } catch (error) {
            showMessage(`加载数据集失败: ${error.message}`, 'error');
            return false;
        }
    }
function trainModel() {
    if (trainData.length === 0) { showMessage("请先加载数据集", 'error'); return; }
    const loadingSpinner = document.getElementById('loading-spinner');
    loadingSpinner.style.display = 'flex';

    try {
        fetch('/api/gm11/train', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ train_data: trainData }),
        })
        .then(response => {
            loadingSpinner.style.display = 'none';
            if (!response.ok) {
                return response.text().then(text => {
                    throw new Error(`HTTP错误: ${response.status} - ${text}`);
                });
            }
            return response.json();
        })
        .then(responseData => {
            if (!responseData) throw new Error("服务器返回空响应");
            if (responseData.success) {
                modelTrained = true;
                showMessage("模型训练成功", 'success');
                // 保存训练参数供预测使用
                window.gm11Params = responseData;
            } else {
                throw new Error(responseData.error || "模型训练失败");
            }
        })
        .catch(error => {
            loadingSpinner.style.display = 'none';
            showMessage(`训练模型失败: ${error.message}`, 'error');
        });
    } catch (error) {
        loadingSpinner.style.display = 'none';
        showMessage(`训练模型失败: ${error.message}`, 'error');
    }
}

    function performPrediction() {
    if (trainData.length === 0) { showMessage("请先加载数据集", 'error'); return; }
    const loadingSpinner = document.getElementById('loading-spinner');
    loadingSpinner.style.display = 'flex';

    try {
        const predictionStep = parseInt(document.getElementById('prediction-step').value);

        if (isNaN(predictionStep) || predictionStep < 1 || predictionStep > 100) {
            throw new Error("预测步长必须是1-100之间的整数");
        }

        const formData = {
            data_type: document.getElementById('dataset-select').value,
            prediction_step: predictionStep,
            train_data: trainData
        };

        fetch('/api/gm11/predict', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(formData),
        })
        .then(response => {
            loadingSpinner.style.display = 'none';
            if (!response.ok) {
                return response.text().then(text => {
                    throw new Error(`HTTP错误: ${response.status} - ${text}`);
                });
            }
            return response.json();
        })
        .then(responseData => {
            if (!responseData) throw new Error("服务器返回空响应");
            if (responseData.success) {
                showMessage("预测成功完成", 'success');
                updatePredictionResults(responseData);
            } else {
                throw new Error(responseData.error || "预测失败");
            }
        })
        .catch(error => {
            loadingSpinner.style.display = 'none';
            showMessage(`预测失败: ${error.message}`, 'error');
        });
    } catch (error) {
        loadingSpinner.style.display = 'none';
        showMessage(error.message, 'error');
    }
}
    function updatePredictionResults(data) {
        const accuracyMetrics = document.getElementById('accuracy-metrics');
        accuracyMetrics.style.display = 'grid';
        document.getElementById('mae-value').textContent = formatNum(data.mae, 6);
        document.getElementById('mse-value').textContent = formatNum(data.mse, 6);
        document.getElementById('rmse-value').textContent = formatNum(data.rmse, 6);
        document.getElementById('r2-value').textContent = formatNum(data.r2_score, 6);
        document.getElementById('accuracy-value').textContent = formatPct(data.accuracy, 3);

<!--        // 更新下一次失效预测时间-->
<!--        document.getElementById('next-failure-time').textContent = data.next_failure_time !== undefined ? data.next_failure_time.toFixed(2) : 'N/A';-->

<!--        // 更新预测时间点列表-->
<!--        const predictionTimesList = document.getElementById('prediction-times-list');-->
<!--        if (data.predicted_times && data.predicted_times.length > 0) {-->
<!--            predictionTimesList.innerHTML = data.predicted_times.map((t, i) => `<li>第${i+1}次: ${t.toFixed(2)}</li>`).join('');-->
<!--        } else {-->
<!--            predictionTimesList.innerHTML = '<li>无预测数据</li>';-->
<!--        }-->

        // 更新表格
        updateIntervalTable(data);

        // 更新残差统计
        updateResidualStats(data.residual_stats);

        // 更新图表
        updateCharts(trainData, data.full_predicted_intervals, data.predicted_intervals);
    }

    function updateIntervalTable(data) {
        const tbody = document.getElementById('interval-table-body');
        tbody.innerHTML = '';

        if (!data.original_intervals || data.original_intervals.length === 0) return;

        const nOriginal = data.original_intervals.length;
        const nFitted = data.x0_hist_fit ? data.x0_hist_fit.length : 0;
        const nResiduals = data.residuals ? data.residuals.length : 0;
        const nFull = data.full_predicted_intervals ? data.full_predicted_intervals.length : 0;

        for (let i = 0; i < nFull; i++) {
            const row = document.createElement('tr');

            // 序号
            const idxCell = document.createElement('td');
            idxCell.textContent = i + 1;
            idxCell.style.border = '1px solid #ddd';
            idxCell.style.padding = '8px';
            row.appendChild(idxCell);

            // 原始间隔
            const origCell = document.createElement('td');
            origCell.textContent = i < nOriginal ? data.original_intervals[i].toFixed(2) : '-';
            origCell.style.border = '1px solid #ddd';
            origCell.style.padding = '8px';
            row.appendChild(origCell);

            // 拟合间隔
            const fitCell = document.createElement('td');
            fitCell.textContent = i < nFitted ? data.x0_hist_fit[i].toFixed(2) : '-';
            fitCell.style.border = '1px solid #ddd';
            fitCell.style.padding = '8px';
            row.appendChild(fitCell);

            // 残差
            const resCell = document.createElement('td');
            resCell.textContent = i < nResiduals ? data.residuals[i].toFixed(2) : '-';
            resCell.style.border = '1px solid #ddd';
            resCell.style.padding = '8px';
            row.appendChild(resCell);

            // 预测间隔（只有预测部分有值）
            const predCell = document.createElement('td');
            predCell.textContent = i >= nOriginal && i < nFull ? data.full_predicted_intervals[i].toFixed(2) : '-';
            predCell.style.border = '1px solid #ddd';
            predCell.style.padding = '8px';
            row.appendChild(predCell);

            tbody.appendChild(row);
        }
    }

    function updateResidualStats(stats) {
        document.getElementById('residual-mean').textContent = stats && stats.residual_mean !== undefined ? stats.residual_mean.toFixed(4) : 'N/A';
        document.getElementById('residual-std').textContent = stats && stats.residual_std !== undefined ? stats.residual_std.toFixed(4) : 'N/A';
        document.getElementById('residual-max').textContent = stats && stats.residual_max !== undefined ? stats.residual_max.toFixed(4) : 'N/A';
        document.getElementById('residual-min').textContent = stats && stats.residual_min !== undefined ? stats.residual_min.toFixed(4) : 'N/A';
        document.getElementById('residual-range').textContent = stats && stats.residual_range !== undefined ? stats.residual_range.toFixed(4) : 'N/A';
    }

    function fetchDatasetList() {
        fetch('/api/data/list')
        .then(res => res.json())
        .then(data => {
            if (data.success) {
                const select = document.getElementById('dataset-select');
                const group = document.createElement('optgroup');
                group.label = "我的云端数据";
                data.data.forEach(item => {
                    const opt = document.createElement('option');
                    opt.value = `db:${item.id}`;
                    opt.textContent = `[云端] ${item.name} (${item.count}点)`;
                    group.appendChild(opt);
                });
                select.appendChild(group);
            }
        });
    }

    document.addEventListener('DOMContentLoaded', function() {
        initCharts();
        document.getElementById('dataset-select').addEventListener('change', function() {
            const customGroup = document.getElementById('custom-dataset-group');
            if (this.value === 'custom') {
                customGroup.style.display = 'block';
            } else {
                customGroup.style.display = 'none';
                loadDataset(this.value);
            }
        });
        document.getElementById('train-ratio-slider').addEventListener('input', function() {
            document.getElementById('train-ratio-value').textContent = `${this.value}%`;
        });
        document.getElementById('load-dataset-btn').addEventListener('click', function() {
            loadDataset('custom');
        });
        document.getElementById('train-btn').addEventListener('click', trainModel);
        document.getElementById('predict-btn').addEventListener('click', performPrediction);

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                const tabContents = {
                    '模型简介': document.getElementById('model-intro-content'),
                    '失效数据': document.getElementById('dataset-content'),
                    '预测分析': document.getElementById('prediction-content')
                };
                Object.values(tabContents).forEach(content => {
                    if (content) content.style.display = 'none';
                });
                const tabName = this.textContent.trim();
                if (tabContents[tabName]) {
                    tabContents[tabName].style.display = 'block';
                }
            });
        });
        document.querySelectorAll('.tab')[0].click();
        loadDataset('default');
        fetchDatasetList();
    });
</script>
{% endblock %}